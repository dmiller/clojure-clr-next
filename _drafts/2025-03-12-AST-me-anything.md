---
layout: post
title: C4 - AST me anything
date: 2025-03-12 00:00:00 -0500
categories: general
---


We explain all the AST node types generated by the compiler.  Buckle up.


## The roots

To be an an AST node, a class must implement the `clojure.lang.Compiler.Expr` inteface:

```C#
    public interface Expr
    {
        // provides typing information
        bool HasClrType { get; }
        Type ClrType { get; }

        // Supports direct evaluation and code generation
        object Eval();
        void Emit(RHC rhc, ObjExpr objx, CljILGen ilg);

        // Technical detail -- more later.
        bool HasNormalExit();
    }
```

In addition, some node types support the possibility of generating unboxed primitive values and have special code generation code for this.  These types implement `MaybePrimitiveExpr`:

```C#
    public interface MaybePrimitiveExpr : Expr
    {
        // Whether or not this instance can 
        bool CanEmitPrimitive { get; }

        // Emit without boxing
        void EmitUnboxed(RHC rhc, ObjExpr objx, CljILGen ilg);
    }
```

Finally, one interface indicates that the expression can be the target of a `set!`.  These node types must supply their own code generation for doing assignment, either in direct evaluation or for code generation:

```C#
    public interface AssignableExpr
    {
        object EvalAssign(Expr val);
        void EmitAssign(RHC rhc, ObjExpr objx, CljILGen ilg, Expr val);

    }
```

## The (really) big picture

See and believe.

<img src="{{site.baseurl | prepend: site.url}}/assets/images/xpr-type-dependencies.dot.png" alt="Graph of all AST node types" />


To make this is a bit more manageable, we can cluster the node types according to some common traits beyond just inheritance.

__Cluster #1 -- Data values__: Some of the node types wrap a data value.  This includes all of the subtypes of `LiteralExpr` -- literal constants.   

| Expr type | Description |
|:----------|:------------|
| `BooleanExpr` |   Holds a true/false value  |
| `KeywordExpr` |   Holds a keyword  |
| `NilExpr` |   Nil, just nil.  |
| `NumberExpr ` |   Holds an `int`, `long`, or `double`.  Other numeric types will be held in a `ConstantExpr`.  |
| `StringExpr ` |   You guessed it.  |
| `ConstantExpr ` |  Literal values not of the types listed above.  This includes maps, sets, and vectors that are constants, not formed by evaluating expressions.   Compare `[1 2 3]` to `[x y z]`.  It also includes numeric values not covered by `NumberExpr`, types, and variety of other things.  Some values might cause errors during code gen because we just don't know how to deal with them.  (For evalution, we can just return the value that was given.) |

Those that are not under `LiteralExpr` typically have more specialized code for construction, typing calcuations,  or evaluation/code-gen. One subcluster relates to maps, sets, and vectors

| Expr type | Description |
|:----------|:------------|
| `EmptyExpr` |   Comes from a collection type value that is empty and has no meta data.  Will evaluate to or generate code to create an empty list, map, set, or vector.  |
| `MapExpr` |  Create a map from supplied key/value pairs, some of which themselves are expressions.  |
| `SetExpr` |  Similarly for sets.  |
| `VectorExpr  ` |   Similarly for vectors.  |


And two node types relate specifically to `Var`s:

| Expr type | Description |
|:----------|:------------|
| `TheVarExpr ` |  Related to the `#'name`  syntax |
| `VarExpr` |   A symbol in the code text maps to a `Var`.  |
  

__Cluster #2 -- Control flow__: There are a few node types related to what we might call the flow of control:


| Expr type | Description |
|:----------|:------------|
| `BodyExpr ` |  A sequence of expressions to evaluate, returning the value of the last one.  The `do` form translates to this, but other constructs, such as the body of a function method, have _implicit do_ structure. |
| `CaseExpr ` |  Obvious, I hope. |
| `IfExpr ` |    Even more obvious. |
| `ThrowExpr` |  Duh. |
| `TryExpr` |  This has the main body, catch clauses (can be none), and an optional finally clause. |


__Cluster #3 -- Miscellaneous__: The things that I can't figure out another home for.

| Expr type | Description |
|:----------|:------------|
| `AssignExpr` | Comes from a `(set! targe value)` expression |
| `DefExpr`  | Comes from a `(def name value)` expression.  This includes `defn`, `defmacro` and other forms that macroexpad to a `def` | 
| `ImportExpr`  | Yep, `(import* ...)` gets its own node type |
| `InstanceOfExpr  `  | Yep, `(instance-of ...)` ... |
| `MetaExpr` | When we need to attach metadata to some other construct as we eval/code-gen.  Primiarly used for functions and the collections (map, set, vector) |
| `MonitorEnterExpr` | Yep. | 
| `MonitorExitExpr` | Just what you think. |
| `UnresolvedVarExpr`  | There is a compiler mode that allows a symbol that we can resolve to something (local binding, `Var`, typename, etc., i.e., does not throw an error when encountered.  We create this node for one of those.  It is supposed to allow an extension point.  No known uses of it. |
| `UntypedExpr` | This is just an abstract base class for certain other node types that don't have a return type:  `MonitorEnterExpr`, `MonitorExitExpr`, `ThrowExpr` |

__Cluster #4 -- Host interop__:  
The subtypes of `HostExpr` are all related to platform calls:  methods, properties, fields, etc.  There are a few node types similarly oriented that are not under `HostExpr`.   I may went a little overboard with the class hierarchy, but there was common code that seemed to make this structure sensible.    Things are a little more complicated on the CLR vs the JVM because the CLR has properties as first-class objects.  That also increases the confusion level between no-argument constructs:  Is this call to access a field, access a property, or call a 0-arity method.
Ignoring some of the intermediate abstract classes, we can organize the majority of the concrete classes as follows:

|     |  Field   |  Property     |  Method    |
|:-------:|:-------:|:-------:|:-------:|
| Instance  | `InstanceFieldExpr` | `InstancePropertyExpr` | `InstanceMethodExpr`  |
| Static    | `StaticFieldExpr` | `StaticPropertyExpr` | `StaticInvokeExpr` | `StaticMethodExpr` |

The remaining `HostExpr`-derived class is:

| Expr type | Description |
|:----------|:------------|
| `InstanceZeroArityCallExpr` | An interop call with no arguments, but we can't figure out if it is a field, property, or expression.  Reflection is going to be happening. |

There are two other node types I think goes into this cluster:


| Expr type | Description |
|:----------|:------------|
| `QualifiedMethodExpr` | This results from the fairly recent introduction of qualified method expressions of the form `Type/.Name` for instance method calls, `Type/new` for constructor calls, and `Type/name` for static calls.  During analysis, this node type sometimes resolved into one of the `HostExpr` types, but sometimes it generates a value (a 'thunk') to be passed as an argumment. |
| `NewExpr` | A constructor call to 'new' a type. |


__Cluster #5 -- Functions and local binding scopes__: These node types related to the definition of functions or local-binding scopes.

`ObjExpr` is the abstract base class for two concrete classes:

| Expr type | Description |
|:----------|:------------|
| `FnExpr` | From `(fn* name ...)` forms |
| `NewInstanceExpr` | from `deftype` and `reify` definitions |

I have no idea why `ObjExpr` and `NewInstanceExpr` are so named.
These create a scope for the definition of and reference to local bindings.
They cause the creation of types that implement the `IFn` interface of `invoke` methods.

Though not AST nodes themselves, the types `FnMethod` and `NewInstanceMethod` encode the individual 'invoke' method definitions.

Also creating scopes are:

| Expr type | Description |
|:----------|:------------|
| `LetExpr` | From `(let [...] ...)` and `(loop [...] ...)` forms |
| `LetFnExpr` | From `(letfn [...] ...)` |

For technical reasons, parsing of these constructs at the top level involves wrapping them with a dummy function.  The dummy function provides the machinery for local binding creation, scope and reference.  Thus, the analyzer would transform

```clojure
(let [x 12] (inc x))
```

into

```clojure
( (fn* [] (let [x 12] (inc x))) )
```

This need only happen at the top level. If a `let` form was inside a function definition already, this wrapping would not be necessary.

The `loop` special form explictly creates a scope for iteration via `recur`; function bodies implicly create such a scope. A `recur` form in such a context will be represented by


| Expr type | Description |
|:----------|:------------|
| `RecurExpr` | From a `(recur ...)` form |


Given that we introduced local bindings, we need to reference the values of local bindings in our code.  This is handled by:


| Expr type | Description |
|:----------|:------------|
| `LocalBindingExpr` | A reference to a `LocalBinding`  |


A `LocalBinding` encodes information about the local binding definition, such as its name an initialization expression.

Finally, there is the node type:

| Expr type | Description |
|:----------|:------------|
| `MethodParamExpr` | Holds the type of a method parameter. |

You'll never see one of these running free.  They are used internally only.  They can't be evaluated and cannot generate code.  Why they are a subtype of `Expr` is a bit of a mystery to me.

__Cluster #6: -- Invocation__: These are involved with function invocation.



| Expr type | Description |
|:----------|:------------|
| `InvokeExpr` |  A general invocation of the form `(f ...args)` |
| `KeywordInvokeExpr`  | An invocation fo the form `(:kw arg)` |
| `StaticInvokeExpr`  | for direct linking a function invocation, call a `staticInvoke` overload (more later) |


And there you have the managerie.  You'll have to decide in this zoo which cluster is the reptile house, which the primate house, and so on.


## Analysis

Creation of the AST tree for a form proceeds by recursive descent through the form.
The basic structure of the form is identified and the appropriate specialized parser is called.
For example, if a `(do form1 form2 ...) ` construct was seen, the `do` indicates that the `BodyExpr` parser is appropriate.  That parser would receive `(form1 form2 ...)`.  It would recursively analyze each of the forms in turn, creating `Expr`s for each. Finally, it would create a `BodyExpr` holding that sequence of `Expr`s.  For technical reaosns, the last such would be receive special treatment.  Its type is the type reported by the `BodyExpr`.  The value it returns on evalution or code generation becomes the value returned by the `BodyExpr`.

The main body of the `Compiler.Analyze` method just steps through a series of tests to determine what auxiliary parser to call.

|  Test: the form is ... | Action |
|:------|:-------|
| `nil` | Create a `NilExpr` |
| `true` or `false` | Create a `BooleanExpr` |
| a symbol | Call the symbol analyzer (see below) |
| a keyword | Create a `KeywordExpr` |
| a number | Create a `NumberExpr` (if an `int`, `long`, or `double`) or a `ConstantExpr` |
| a string | Create a `StringExpr` |
| an `IPersistentCollection` <br/> not an `IRecord` or `IType` <br/> has no elements | create an `EmptyExpr` |
| an `ISeq` | call the `ISeq` analyzer (see below) |
| an `IRecord` or `IType` | createa a `ConstantExpr` |
| `IPersistentVector` | create a `VectorExpr` or a `ConstantExpr` |
| `IPersistentMap` | create a `MapExpr` or a `ConstantExpr` |
| `IPersistentSet` | create a `SetExpr` or a `ConstantExpr` |
| otherwise | create a `ConstantExpr` and hope it can be handled if we are compiling |

The symbol analyzer does a lot of analysis, corresponding to the many things a symbol can refer to. It deserves its own post, [Symbolic of what?]({{site.baseurl}}{% post_url 2025-03-13-symbolic-of-what}).

The `ISeq` analyzer is `Compiler.AnalyzeSeq`. It receives an ISeq, which will be of the form `(op ...args...)`.
It first tries to macroexpand the form.  If macroexpanding gives us back soemthing other than what we started with, it just calls `Compiler.Analyze` on that new things.  Otherwise:


- if `op` is `nil`, throw an exception
- if `op` is a `Var` or a symbol that resolves to a `Var`, and that `Var` has `:inline` metadata with an entry with correct number of arguments, invoke that entry (it should be an `IFn`) on the arguments and recursively analyze the result.  
- If `op` is a special form, call the corresponding special form parser. (See below).
- Otherwise, call the parse for `InvokeExpr` (Also see below.)


The compiler has a map from special form symbols to the parser to be used for that special form.
Here you go:

|  Special form op | Hander |
|:-----------------|:----|
| `case*` | `CaseExpr` |
| `def` | `DefExpr` |
| `deftype*` | `DefType.Parser`, contained in `NewInstanceExpr` |
| `do`    | `BodyExpr` |
| `fn*` |  `FnExpr` |
| `if` | `IfExpr` |
| `import*` | `ImportExpr` |
| `let*`  | `LetExpr` |
| `letfn*` | `LetFnExpr` |
| `loop*` |  `LetExpr` |
| `monitor-enter` | `MonitorEnterExpr` |
| `monitor-exit` | `MonitorExitExpr` |
| `new` | `NewExpr` |
| `quote` | `ConstantExpr` |
| `recur` | `RecurExpr` |
| `reify*` |  `Reify.Parser`, contained in `NewInstanceExpr` |
| `set!` | `AssignExpr` |
| `throw` | `ThrowExpr` |
| `try` | `TryExpr` |
| `var` | `TheVarExpr` |
| `.` | `HostExpr` |

Some of the op names have an asterisk at the end.
These are the primitive forms that more advanced syntactic constructs macroexpand into.
For example, `let` has a lot of special handling for deconstructing arguments.
A `let` form will macroexpand into a `let*` that has only simple bindings.  E.g.

```clojure
(let [[x y] (f 12)] something)
```

macroexpands to 

```clojure
(let*
 [vec__24820 (f 12)
  x          (clojure.core/nth vec__24820 0 nil)
  y          (clojure.core/nth vec__24820 1 nil) ]
 something)
 ```

Also, some operators you are unlikely to type directly.  More commonly they come from reader macros, e.g.,

- `'x`  => `(quote x)`
- `#'x` => `(var x)`


### The invocation parser   

The catch-all parser at the end of `AnalyzeSeq` is `InvokeExpr.Parser.Parse`.  It might not return an `InvokeExpr`.
It could alternatively return a `KeywordInvokeExpr` or a `StaticInvokeExpr`.  
I discussed static invocation in another blog post, [The function of naming; the naming of functions]({{site.baseurl}}{% post_url 2025-02-28-function-naming}).


## Conclusion

There are many devils hidden in the details of the many parsers mentioned above.  There is no substitute for actually looking at each one in turn to understand their peculiarities.    I hope the organization presented here makes that taks less daunting.  In addition, subsequent blog posts will provide overviews of some of the more complex pieces, such as function management and interop.

